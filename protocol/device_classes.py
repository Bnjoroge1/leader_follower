
from dataclasses import asdict
import os
import time
import uuid
from message_classes import Message, Action
#from zigbee_network import ZigbeeTransceiver
from typing import Dict, List, Optional, Set
from pathlib import Path
import csv
import json
from device_state import DeviceState, DeviceStateStore
import random
from multiprocessing import Queue as MPQueue
import asyncio
from abstract_network import AbstractTransceiver
# zigpy imports      
#import asyncio
#from zigpy.zcl.clusters.general import OnOff
#from zigpy.types import EUI64

CURRENT_FILE = Path(__file__).absolute()
PROTOCOL_DIR = CURRENT_FILE.parent
OUTPUT_DIR = PROTOCOL_DIR / "output"

PROVEN_MAX_WAIT_TIME = 2
MISSED_THRESHOLD: int = 5
RESPONSE_ALLOWANCE: float = 1  # subject to change
PRECISION_ALLOWANCE: int = 5
SETUP_WAIT = 5
RECEIVE_TIMEOUT: float = 0.5
ATTENDANCE_DURATION: float = 1
D_LIST_DURATION: float = 2
DELETE_DURATION: float = 2
TAKEOVER_DURATION: float = 15



class Device:
    """ Lightweight device object for storing in a DeviceList. """

    def __init__(self, id):  # id will be generated by ThisDevice before attendance response
        """
        Non-default constructor for Device object.
        :param id: specified identifier for instance.
        """
        self.id: int = id  # unique device identifier, randomly generated
        
        
        self.leader: bool = False  # initialized as follower
        self.received: int | None # holds most recent message payload
        self.missed: int = 0  # number of missed check-ins, used by current leader
        self.in_election: bool = False
        self.task: int = 0  # task identifier, 0 denotes reserve
        

    def get_id(self) -> int:
        """
        :return: Device's identifier.
        """
        return self.id

    def get_leader(self) -> bool:
        """
        :return: Device's current leader status.
        """
        return self.leader

    def get_received(self) -> int | None:
        """
        :return: Device's most recently received message.
        """
        return self.received

    def get_missed(self) -> int:
        """
        :return: number of missed check-ins for this Device.
        """
        return self.missed

    def reset_missed(self):
        self.missed = 0

    def get_task(self) -> int:
        """
        :return: device's current task identifier
        """
        return self.task

    async def make_leader(self):
        """
        Makes this Device a leader
        """
        self.leader = True
        
        self.leader_id = self.id
        print("Device", self.id, "becoming leader (lowest ID)")
        print("--------Leader---------")
        
        # Send immediate attendance message to prevent follower timeouts
        


    async def make_follower(self):
        """
        Makes this Device a follower
        """
        self.leader = False

    def incr_missed(self) -> int:
        """
        Increments number of missed check-ins by 1.
        :return: new number of missed check-ins.
        """
        self.missed += 1
        return self.missed

    def set_task(self, task: int):
        """
        Sets the task for this Device.
        :param task: task's int identifier
        """
        self.task = task

class ThisDevice(Device):
    """ Object for main protocol to use, subclass of Device. """

    def __init__(self, id, transceiver):  # inclusive bounds

        """
        Constructor (default/non-default) for ThisDevice, creates additional fields.
        :param id: identifier for ThisDevice, either pre-specified or randomly generated.
        """
        
        
        self.id = random.randint(1, 1000000) % int(1e6)
        super().__init__(id)
        self.leader: bool = True  # start ThisDevice as leader then change accordingly in setup
        self.device_list: DeviceList = DeviceList()  # default sizing
        self.leader_id: int
        self.leader_started_operating: float | None = None
        self.task_folder_idx: int | None = None  # multiple operations can be preloaded
        self.received: int | None = None  # will be an int representation of message
        self.transceiver: Optional[AbstractTransceiver] = transceiver  # plugin object for sending and receiving messages
        self.numHeardDLIST: int = 0
        os.makedirs(OUTPUT_DIR, exist_ok=True)
        self.outPath = OUTPUT_DIR / ("device_log_" + str(self.id) + ".csv")
        self.active = True
        self.is_ui_device = False
        self.known_leaders = set()  #keep track of all leaders with lower IDs.
        self.ui_update_queue = MPQueue()
       
        #persistent id
        self.device_uuid = self._get_or_create_uuid()
        self.last_heard_from_leader = time.time()
        self.disconnected = False

        
    def _get_or_create_uuid(self):
        """
        Generate or retrieve a persistent UUID for this device"""
        uuid_file = Path(f"device_uuid{self.id}.json")
        if uuid_file.exists():
            try:
                with open(uuid_file, 'r') as file:
                    return json.load(file).get('uuid')
            except(json.JSONDecodeError, KeyError, FileNotFoundError):
                pass

        new_uuid  = str(uuid.uuid4())
        with open(uuid_file, 'w') as f:
            json.dump({'device_uuid ': new_uuid}, f)
        return new_uuid
    




    async def send(self, action: int, payload: int, leader_id: int, follower_id: int, duration: float = 0.0):
        """
        Generates message with given parameters and sends to entire channel through transceiver.
        :param action: action
        :param payload: payload
        :param leader_id: leader_id
        :param follower_id: follower_id
        :param duration: sending duration in seconds
        """
        msg = Message(action, payload, leader_id, follower_id).msg
        if not self.active:
            print(f"DEBUG: Device {self.id} is inactive, cant send")
            return
        # single-send with assumed perfect channel
        # users take responsibility of implementing duration send where needed
        if self.transceiver:
            await self.transceiver.async_send(msg)  # transceiver only deals with integers
            self.log_message(msg, 'SEND')
        else:
            print(f"WARN: Device {self.id} has no transceiver to send to.")

    async def receive(self, duration: float, action_value: int = -1) -> bool:
        """
        Listens for a message for a specified duration, processing messages until
        a match for action_value is found or the duration expires.

        Args:
            duration: The maximum time to listen in seconds.
            action_value: The specific action code to listen for.
                          If -1, accepts any valid message that passes other checks.

        Returns:
            True if a message matching action_value (or any valid message if -1)
            is received and processed within the duration, False otherwise.
            Sets self.received to the raw message int if True.
        """
        if not self.transceiver:
            print(f"WARN: Device {self.id} has no transceiver to receive.")
            # Respect duration even if no transceiver
            await asyncio.sleep(duration if duration > 0 else 0.01)
            return False

        loop = asyncio.get_running_loop()
        start_time = loop.time()
        end_time = start_time + duration

        self.received = None # Ensure received is None initially

        while True:
            current_time = loop.time()
            if current_time >= end_time:
                # print(f"DEBUG: Device {self.id} receive duration expired.") # Can be noisy
                break # Total duration expired

            # Calculate remaining time for this receive attempt
            # Use a small, fixed timeout for individual async_receive calls
            # to allow the loop to check the total duration frequently.
            time_left = end_time - current_time
            # Use RECEIVE_TIMEOUT or remaining time, whichever is smaller
            receive_attempt_timeout = min(RECEIVE_TIMEOUT, time_left)

            if receive_attempt_timeout <= 0:
                 # print(f"DEBUG: Device {self.id} no time left for receive attempt.") # Can be noisy
                 break # No time left

            try:
                # Directly await the transceiver's async_receive method.
                # Wrap with wait_for to handle the timeout for this specific attempt.
                # print(f"DEBUG: Device {self.id} awaiting async_receive with timeout {receive_attempt_timeout:.2f}s") # Can be noisy
                received_msg_int = await asyncio.wait_for(
                    self.transceiver.async_receive(timeout=receive_attempt_timeout), # Pass timeout hint to async_receive if it uses it
                    timeout=receive_attempt_timeout + 0.05 # Outer wait_for slightly longer buffer
                )

                if received_msg_int is not None:
                    # print(f"DEBUG: Device {self.id} received raw message: {received_msg_int}") # Can be noisy
                    # Store raw message temporarily for parsing
                    temp_received = received_msg_int
                    self.received = received_msg_int

                    try:
                        print(f"""Received Leader:{self.received_leader_id()}
                                Received action: {self.received_action()}
                                Received follower: {self.received_follower_id()}
""")
                        received_leader = self.received_leader_id()
                        received_action = self.received_action()
                        received_follower = self.received_follower_id()

                        # --- Handle Tiebreaker ---
                        if not self.in_election and hasattr(self, 'leader_id'):
                            if received_leader != 0 and received_leader != self.leader_id:
                                await self.handle_tiebreaker(received_leader)
                                # State might have changed, but continue processing this message

                        # --- Handle Activate/Deactivate ---
                        # These might change state but shouldn't necessarily stop the receive
                        # loop unless the action_value specifically matches them.
                        if self.leader and received_action == Action.DEACTIVATE.value:
                            print(f"Device {self.id} got deactivated by message")
                            self.active = False
                            self.leader = False
                            # If we were specifically looking for DEACTIVATE, return True
                            if action_value == Action.DEACTIVATE.value:
                                self.received = temp_received # Store final message
                                return True
                            # Otherwise, state changed, but continue listening if duration remains

                        if received_action == Action.ACTIVATE.value and received_follower == self.id:
                            print(f"Device {self.id} got reactivated by message")
                            self.active = True
                            await self.make_follower() # Rejoin as follower
                            # If we were specifically looking for ACTIVATE, return True
                            if action_value == Action.ACTIVATE.value:
                                self.received = temp_received # Store final message
                                return True
                            # Otherwise, state changed, but continue listening if duration remains

                        # --- Check if received message matches requested action ---
                        if action_value == -1 or received_action == action_value:
                            self.received = temp_received # Store final message
                            self.log_message(self.received, 'RCVD')
                            # print(f"DEBUG: Device {self.id} found matching message (action={received_action}). Returning True.") # Can be noisy
                            return True # Found a matching message

                        # If message didn't match action_value, loop continues to wait for another message

                    except ValueError: # Handle potential errors from Message.get_... methods
                        print(f"Device {self.id}: Error parsing received message {temp_received}")
                        self.log_status(f"ERROR_PARSING_RCVD_{temp_received}")
                        # Continue listening within the duration

            except asyncio.TimeoutError:
                # This timeout means self.transceiver.async_receive timed out for receive_attempt_timeout
                # This is expected if no message arrives, just continue the outer loop
                # print(f"DEBUG: Device {self.id} async_receive attempt timed out.") # Can be noisy
                pass
            except asyncio.CancelledError:
                 print(f"Device {self.id} receive task cancelled.")
                 raise # Propagate cancellation
            except Exception as e:
                 print(f"Device {self.id}: Unexpected error during receive: {e}")
                 import traceback
                 traceback.print_exc()
                 # Continue loop or break depending on severity? Let's continue for now.

        # Loop finished because total duration expired without finding a matching message
        # print(f"DEBUG: Device {self.id} receive finished, no matching message found. Returning False.") # Can be noisy
        #self.received = None # Ensure received is None if loop times out
        return False

    def received_action(self) -> int:
        """
        :return: action bit of last received message
        :raise: ValueError if no message was received
        """
        if not self.received:
            raise ValueError("No message was received")
        return self.received // int(1e10)

    def received_leader_id(self) -> int:
        """
        :return: leader id of last received message
        :raise: ValueError if no message was received
        """
        if not self.received:
            raise ValueError("No message was received")
        return self.received % int(1e8) // int(1e4)

    def received_follower_id(self) -> int:
        """
        :return: follower id of last received message
        :raise: ValueError if no message was received
        """
        if not self.received:
            raise ValueError("No message was received")
        return self.received % int(1e4)

    def received_payload(self) -> int:
        """
        :return: payload of last received message
        :raise: ValueError if no message was received
        """
        if not self.received:
            raise ValueError("No message was received")
        return self.received % int(1e10) // int(1e8)

    async def setup(self):
        """
        Startup sequence for ThisDevice. Listens to channel for existing leader.
        Assumes follower if heard, assumes leader otherwise.
        :return: None
        """
        print("Listening for leader's attendance")
        if await self.receive(duration=SETUP_WAIT):
            
            if not self.received_action() == Action.ATTENDANCE.value:
                print("Heard someone, listening for attendance")
                await self.receive(duration=15, action_value=Action.ATTENDANCE.value)
            if self.received and self.received_action() == Action.ATTENDANCE.value:
                print("Heard attendance, becoming follower")          
                self.transceiver.parent.trace_point("BECOMING_FOLLOWER")
                await self.make_follower()
                await self.follower_handle_attendance()
                return  # early exit if follower

        if self.is_ui_device:
            await self.make_follower()
        else:
            print("Assuming position of leader")
            await self.make_leader()
            self.leader_id = self.id
            task = self.device_list.unused_tasks()[0]
            await self.device_list.add_device(id=self.id, task_index=task, thisDeviceId= self.id)  # put itself in devicelist with first task
            print(f"DEBUG: Leader {self.id} added itself. Task in list: {self.get_task()  if self.get_task() else 'Not Found'}")

            await self.leader_send_attendance()

    async def leader_send_attendance(self):
        """
        Sending and receiving attendance sequence for leader. Updates and
        broadcasts device list if new device is heard.
        """
        if not self.active:
            print(f"Leader {self.id} not active. Cant send attendance")
            return 

        print("Leader sending attendance")
        for _ in range(5):
            if not self.active:
                print(f"leader{self.id} not active. Cant send")
                return

            self.log_status("SENDING ATTENDANCE")
            msg = Message(action=Action.ATTENDANCE.value, payload=0, leader_id=self.id, follower_id=0).msg
            await self.transceiver.async_send(msg)
            print(f"sent attendance as leader. my device id is{self.leader_id}")
        if not self.active:
            return
        
        # prevents deadlock
        while await self.receive(duration=0.1, action_value=Action.ATT_RESPONSE.value):
            if not self.active:
                print(f"leader{self.id} became inactive while listening")
                return
            print("Leader heard attendance response from", self.received_follower_id())
            self.log_status("HEARD ATT_RESP FROM " + str(self.received_follower_id()))
            if self.received_follower_id() not in self.device_list.get_ids():
                unused_tasks = self.device_list.unused_tasks()
                print("Unused tasks: ", unused_tasks)
                self.log_status("UNUSED TASKS: " + str(unused_tasks))
                task = unused_tasks[0] if unused_tasks else 0
                print("Leader picked up device", self.received_follower_id())
                self.log_status("PICKED UP DEVICE " + str(self.received_follower_id()))
                await self.device_list.add_device(id=self.received_follower_id(),task_index=0, 
                thisDeviceId=self.id)  # has not assigned task yet


    def get_state(self) -> DeviceState:
        """Return serializable state of the device"""
        device_state  = DeviceState(
            device_id=self.id,
            device_uuid = self.device_uuid,
            device_list=list(self.device_list.get_device_list().values()),
            known_leaders=self.known_leaders,
            is_leader = self.leader,
            current_leader=self.leader_id,
            received=self.received,
            missed=self.missed,
            task=self.task 
        )
        return device_state

    async def leader_send_device_list(self):
        """
        Helper to leader_send_attendance. Broadcasts message for each new device in network.
        :return:
        """
        for id, device in self.device_list.get_device_list().items():
            # not using option since DeviceList.devices is a dictionary
            # simply sending all id's in its "list" in follower_id position
            print(f"DEBUG: Leader {self.id} preparing D_LIST for {id}. Task value: {device.task}")

            print("Leader sending D_LIST", id, device.task)
            msg = Message(
                action=Action.D_LIST.value, payload=device.task, leader_id=self.id, follower_id=id
            )
            await self.transceiver.async_send(msg.msg)

    # TODO: maybe handle leader collisions/tiebreakers here
    async def leader_perform_check_in(self):
        """
        Leader executes check-in sequence for each follower in device_list. Updates
        number of missed check-ins if a device does not respond in time.
        :return:
        """
        #Take snapshot of device list in a thread-safe manner first
        device_list = self.device_list.get_device_list()
        #create a copy of the device list
        device_list = dict(device_list)
        if not self.active:
            return
        # leader should listen for check-in response before moving on to ensure scalability
        for id, device in device_list.items():
            if not self.active:
                return
                  

                    
            if id == self.id:
                continue

            got_response: bool = False
            # sending check-in to individual device
            print("Leader sending check-in to", id)
            self.log_status("SENDING CHECKIN TO " + str(id))
            checkin_msg = Message(
                action=Action.CHECK_IN.value, payload=0, leader_id=self.id, follower_id=id
            )
            await self.transceiver.async_send(checkin_msg.msg)
            # device hangs in send() until finished sending
            end_time = time.time() + RESPONSE_ALLOWANCE
            # accounts for leader receiving another device's check-in response (which should never happen)
            while time.time() < end_time:  # times should line up with receive duration
                if await self.receive(duration=RESPONSE_ALLOWANCE, action_value=Action.CHECK_IN_RESPONSE.value):
                    # if tiebreak occurred during receive and no longer leader, end check in
                    if not self.get_leader():
                        return
                    
                    if abs(self.received_follower_id() - id) < PRECISION_ALLOWANCE:  # received message is same as sent message
                        # early exit if heard
                        got_response = True
                        print("Leader heard check-in response from", id)
                        self.log_status("HEARD CHECKIN RESPONSE FROM " + str(id))
                        break
            if got_response:
                device.reset_missed()
            else:
                device.incr_missed()
    async def _perform_leader_election(self):
        """
        Performs the elader election by broadcasting candidacies and listening for others. currently, determines the device with the lowest ID. 
        Returns:
        int: The ID of the determin ed elected leader.
        """
        print(f"Device {self.id} starting leader election...")
        self.in_election = True
        self.log_status("STARTING ELECTION")
        # Log to UI if this is happening after timeout
        global global_ui_update_queue
        if hasattr(self, 'ui_update_queue') and self.ui_update_queue:
            log_data = {"level": "INFO", "message": f"Device {self.id} starting election after leader timeout."}
            self.ui_update_queue.put(("log_event", log_data))
        # Add a small random delay before broadcasting to reduce collisions
        await asyncio.sleep(random.uniform(0.1, 0.5))
        received_candidacies = {self.id} # Track IDs seen, including self

        election_duration = 10.0  # Election window duration in seconds
        lowest_id_seen = self.id

        # Broadcast candidacy multiple times initially
        
        await self.broadcast_candidacy()
        await asyncio.sleep(random.uniform(0.1, 0.3)) # Space out broadcasts

        print(f"Device {self.id} listening during election window ({election_duration}s)")
        self.log_status("ELECTION_LISTENING")

        election_end = time.time() + election_duration
        while time.time() < election_end:
            # Listen for short intervals within the election window
            if await self.receive(duration=2): # Listen for 0.5s
                # Check if the received message is a candidacy broadcast
                if self.received_action() == Action.CANDIDACY.value:
                    other_id = self.received_leader_id()
                    # Candidacy messages use the sender's ID in the leader_id field
                    if other_id != 0: # Ignore if leader_id is 0 (not a valid candidacy)
                        print(f"Device {self.id} received candidacy from {other_id}")
                        self.log_status(f"HEARD_CANDIDACY_FROM_{other_id}")
                        received_candidacies.add(other_id)
                        if other_id < lowest_id_seen:
                            lowest_id_seen = other_id
                            self.log_status(f"NEW_LOWEST_ID_SEEN_{lowest_id_seen}")
            # No need to constantly rebroadcast if nothing is heard;
            # rely on initial broadcasts and others' broadcasts.

        print(f"Device {self.id} finished election window.")
        print(f"Device {self.id} saw candidacies from: {received_candidacies}")
        print(f"Device {self.id} determined lowest ID: {lowest_id_seen}")

        self.in_election = False # Mark election as complete
        self.log_status(f"ELECTION_COMPLETE_LOWEST_ID_{lowest_id_seen}")
        return lowest_id_seen

    async def leader_drop_disconnected_devices(self):
        """
        Leader checks for any disconnected devices. If found, updates
        device list and broadcasts delete message to all followers.
        """
        for id, device in self.device_list.get_device_list().copy().items():  # prevents modifying during iteration
            if device.get_missed() > MISSED_THRESHOLD:
                #save file state
                device_state = self.get_state()
                device_storage = DeviceStateStore()
                device_storage.save_device_state(device_id=id, state_dict=asdict(device_state))


                
                self.device_list.remove_device(id=id)  # remove from own list
                # sends a message for each disconnected device
                print("Leader sending DELETE message")
                self.log_status("SENDING DELETE")
                await self.send(action=Action.DELETE.value, payload=0, leader_id=self.id, follower_id=id, duration=DELETE_DURATION)
                # broadcasts to entire channel, does not need a response confirmation
    async def follower_rejoin_after_dropping_off(self):
        #detect if this device has been dropped off. check for messages within TAKEOVER DURATION, and not reeceiveing check in requests. 
        """Handle device rejoining after disconnecting"""
        print("Device {self.id} detected disconnection, attempting to rejoin")
        self.disconnected = True

        #load previous state
        device_storage  = DeviceStateStore()
        previous_state = device_storage.get_latest_device_state(self.id)
        
        if previous_state:
            print(f"Device {self.id}. Found previous state with UUID: {previous_state.get('device_uuid')}")
            self.known_leaders.clear()
        else:
            print(f"Device {self.id} has no previous state, joining as new device")
        #get the current leader
        current_leader  = await self._detect_current_leader()
        if current_leader:
            #current leader exists, so rejoin as follower
            print(f"Device {self.id} detected leader {current_leader}. Becoming its follower ")
            self.leader_id = current_leader
            self.leader = False
            await self.make_follower()
            await self._send_rejoin_request()
        #if no current leader then participate in electon
        else:
            print(f"NO CURRENT LEADER DETECTED BY {self.id}, participating in leader election")
            self.known_leaders.clear()
            await self.broadcast_candidacy()

    async def _detect_current_leader(self):
        """Listen for network activity to identify current leader"""
        print("Device {self.id} listening for current leader")

        #try several short windows instead of one long one
        for _ in range(5):
            if await self.receive(duration=1.0):
                if self.received_action() == Action.ATTENDANCE.value:
                    leader_id = self.received_leader_id()
                    print(f"Device {self.id} detected leader {leader_id}")
                    return leader_id
            await asyncio.sleep(0.2) #small gap between listening attempts.
        print(f"Device {self.id} did not detect any leader")
        return None
    async def _send_rejoin_request(self):
        """
        send the actual rejoin request as a follower to leader"""
        #create a payload with UUID fingerprint
        uuid_hash  = abs(hash(self.device_uuid)) % 10000
        payload = (self.task * 10000) + uuid_hash

        msg = Message(
            action=Action.REJOIN_REQUEST.value,
            payload=payload,
            leader_id=self.leader_id,
            follower_id=self.id,
            
        )
        await self.transceiver.async_send(msg.msg)
        #wait for response with certain timeout
        rejoin_time = time.time() + 5.0
        while time.time() < rejoin_time:
            if await self.receive(duration=0.5):
                if self.received_action() == Action.REJOIN_RESPONSE.value:
                    if self.received_follower_id() == self.id:
                        print(f"Device {self.id} rejoined successfully")
                        self.disconnected = False
                        return True
        print(f"Device {self.id} rejoin request timed out")
        return False
    async def handle_leader_rejoin_request(self):
        """Leader handles a rejoin request from a device"""
        follower_id = self.received_follower_id()
        payload = self.received_payload()
        task = payload // 100000
        uuid_hash = payload % 100000

        print(f"Leader{self.id} received rejoin request from device")

        #validate the device by checking teh stored state
        device_storage = DeviceStateStore()
        matching_states = device_storage.find_states_by_uuid_hash(uuid_hash)

        if matching_states:
            print(f"Leader {self.id} found matching previous state for follower device{follower_id}")
            await self.device_list.add_device(id=follower_id, task_index=self.get_task(), thisDeviceId=self.id)
            
            #send acceptance
            msg = Message(
                action=Action.REJOIN_RESPONSE.value,
                payload=payload,
                leader_id=self.id,
                follower_id=follower_id,
                
            )
            await self.transceiver.async_send(msg.msg)
            #annouce to all other followers
            await self._announce_device_rejoined(follower_id)

            #confirm that all followers have updated their device list. 
            return True

        else:
            print(f"Leader {self.id} couldnt validate device {follower_id}")
            return True
    async def _announce_device_rejoined(self, follower_id):
        """ Announce device has rejoined"""
        for follower in self.device_list.get_ids():
            if follower != self.id and follower != follower_id:
                await self.transceiver.async_send(
                    Message(action=Action.REJOIN_ANNOUNCE.value,
                    payload=0,
                    leader_id=self.id,
                    follower_id=follower_id).msg
                   
                )
    





    async def follower_handle_attendance(self):
        """
            Called after follower has received attendance message and assigned to self.received.
        """
        print("Follower", self.id, "handling attendance")
        self.log_status("HANDLING ATTENDANCE")
        self.leader_id = self.received_leader_id()
        # preconditions handled - always send response
        await asyncio.sleep(ATTENDANCE_DURATION/2)
        msg = Message(
        action=Action.ATT_RESPONSE.value, payload=0, leader_id=self.leader_id, follower_id=self.id
        )
        await self.transceiver.async_send(msg.msg)

    async def follower_respond_check_in(self):
        """
        Called after follower has received check-in message. Responds with same message.
        """
        print("Follower responding to check-in")
        self.log_status("RESPONDING TO CHECKIN")
        await self.transceiver.async_send(Message(action=Action.CHECK_IN_RESPONSE.value, payload=0, leader_id=self.leader_id, follower_id=self.id).msg)
        # sending and receiving is along different channels for Transceiver, so this should not be a problem
    
    async def follower_handle_dlist(self):
        """
        Called after follower receives D_LIST action from leader. Updates device list.
        """
        print(f"Device {self.id} (Leader={self.leader}) handling D_LIST for Follower {self.received_follower_id()} Payload {self.received_payload()}")
        if self.received_follower_id() == self.id:
            print(f"!!! CRITICAL: Device {self.id} (Leader={self.leader}) received D_LIST for ITSELF. Payload={self.received_payload()}.")
            print(f"!!! Checking if self.id ({self.id}) is in keys: {list(self.device_list.get_device_list().keys())}")
            is_in_keys = self.id in self.device_list.get_device_list().keys()
            print(f"!!! Is self.id in keys? {is_in_keys}")
            
        print("Follower handling D_LIST")
        self.log_status("HANDLING DLIST")

        # wipe current device list
        self.device_list.clear()

        # handle already received device from original message
        # only add devices which are not already in device list
        if self.received_follower_id() not in self.device_list.get_device_list().keys():
            self.log_status("ADDING " + str(self.received_follower_id()) + " TO DLIST")
            await self.device_list.add_device(id=self.received_follower_id(), task_index=self.received_payload(), thisDeviceId= self.id)
        # handle the rest of the list
        while await self.receive(duration=0.5, action_value=Action.D_LIST.value):  # while still receiving D_LIST
            # only add new devices
            if self.received_follower_id() not in self.device_list.get_device_list().keys():
                self.log_status("ADDING " + str(self.received_follower_id()) + " TO DLIST")
                await self.device_list.add_device(id=self.received_follower_id(), task_index=self.received_payload(), thisDeviceId= self.id)

    def follower_drop_disconnected(self):
        """
        Called after follower receives DELETE action from leader. Drops device from device list.
        :return:
        """
        print("Follower received DELETE message")
        self.device_list.remove_device(id=self.received_follower_id())
    
    async def handle_tiebreaker(self, other_leader_id: int):
        """
        Called if a device hears a message from a leader different from its current one.
        Ensures the device follows the leader with the lowest ID.
        """
        # --- Pre-conditions ---
        # Ensure we have a current leader ID (it might be 0 initially before election completes)
        # and the other ID is valid (non-zero)
        if not hasattr(self, 'leader_id'):
             # Should not happen if initialized correctly, but safety check
             print(f"Device {self.id}: Tiebreaker check skipped - self.leader_id attribute missing.")
             return
        if other_leader_id == 0:
             print(f"Device {self.id}: Tiebreaker ignored - heard from invalid leader ID 0.")
             self.log_status(f"TIEBREAK_IGNORE_INVALID_OTHER_LEADER_0")
             return
        # If we don't have a leader yet (leader_id is 0), accept the first valid leader heard.
        if self.leader_id == 0:
             print(f"Device {self.id}: Tiebreaker - Accepting first heard leader {other_leader_id}.")
             self.log_status(f"TIEBREAK_ACCEPTING_FIRST_LEADER_{other_leader_id}")
             self.leader_id = other_leader_id
             if self.leader: # If I thought I was leader but hadn't set leader_id yet
                await self.make_follower() # Step down immediately
             return
        # Ignore if it's the same leader we already know
        if other_leader_id == self.leader_id:
             return

        print(f"Device {self.id}: Tiebreaker check - Current Leader: {self.leader_id}, Heard Leader: {other_leader_id}")
        self.log_status(f"TIEBREAK_CHECK_CURRENT_{self.leader_id}_HEARD_{other_leader_id}")

        # --- Logic ---
        # Case 1: Heard leader has a LOWER ID than my current leader
        if other_leader_id < self.leader_id:
            print(f"Device {self.id}: Heard leader {other_leader_id} has lower ID than current leader {self.leader_id}.")
            if self.leader:
                # I was a leader, but someone with a lower ID exists. I must step down.
                print(f"Device {self.id}: Stepping down to become follower of {other_leader_id}.")
                self.log_status(f"TIEBREAK_STEPPING_DOWN_FOR_{other_leader_id}")
                # self.known_leaders.add(self.id) # Record that I yielded
                await self.make_follower() # This sets self.leader = False and sends NEW_FOLLOWER msg
                self.leader_id = other_leader_id # Update to follow the new leader
            else:
                # I was already a follower, but need to switch to the leader with the lower ID.
                print(f"Device {self.id}: Switching follower allegiance from {self.leader_id} to {other_leader_id}.")
                self.log_status(f"TIEBREAK_SWITCHING_FOLLOWER_TO_{other_leader_id}")
                self.leader_id = other_leader_id
                # Optional: Send ATT_RESPONSE to the new leader? Might be handled by regular attendance.

        # Case 2: Heard leader has a HIGHER ID than my current leader
        elif other_leader_id > self.leader_id:
            print(f"Device {self.id}: Heard leader {other_leader_id} has higher ID than current leader {self.leader_id}. Ignoring.")
            self.log_status(f"TIEBREAK_IGNORE_HIGHER_ID_{other_leader_id}")
            # My current leader (with the lower ID) is correct.
            # The device with ID `other_leader_id` is responsible for detecting `self.leader_id`
            # (when my leader sends a message) and stepping down itself.
            # This device takes no action based on hearing a higher ID leader.
            # Optional: If I am the leader, maybe send an ATTENDANCE message to assert my leadership?
            # if self.leader:
            #    print(f"Device {self.id}: Re-asserting leadership after hearing higher ID {other_leader_id}")
            #    self.leader_send_attendance() # Be careful not to spam
            pass

    def log_message(self, msg: int, direction: str):
        #self.csvWriter.writerow([str(time.time()), 'MSG ' + direction, str(msg)])
        #self.file.flush()
        pass

    def log_status(self, status: str):
        #self.csvWriter.writerow([str(time.time()), 'STATUS', status])
        #self.file.flush()
        pass

    # START TEST HARNESS FUNCTIONS

    async def make_follower(self):
        await super().make_follower()
        rcvd_leader_id = self.received_leader_id() if self.received else 0
        asyncio.create_task(self.send(action=Action.NEW_FOLLOWER.value, payload=0, leader_id=rcvd_leader_id, follower_id=self.id)) #type:ignore
        self.log_status("BECOMING FOLLOWER")
    def update_leader(self, new_leader_id):
        pass

    async def make_leader(self):
        await super().make_leader()
       
        if hasattr(self, 'is_ui_device') and self.is_ui_device:
            self.update_leader(self.id)
        msg = Message(
            action=Action.NEW_LEADER.value, payload=0, leader_id=self.id, follower_id=0
        )
        await self.transceiver.async_send(msg.msg)
        self.log_status("BECOMING LEADER")
        try:
            await self.leader_send_attendance()
        except Exception as e:
            print(f"Error sending initial attendance: {e}")
        
    # def test_setup_leader_only_sends_attendance(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')

    #         self.make_leader()
    #         # only send once
    #         self.leader_send_attendance()

    # def test_setup_follower_send_att_response(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
    #         await asyncio.sleep(0.5)
    #         self.make_follower()
    #         self.send(2, 0, 0, self.id)

    # def test_setup_leader_send_attendance_after_att_response(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')

    #         self.make_leader()

    #         await asyncio.sleep(1.5)
    #         self.send(1, 0, self.id, 0)

    # def test_setup_leader_send_two_d_list(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
    #         self.make_leader()
    #         self.send(3, 1, self.id, 0)
    #         await asyncio.sleep(0.5)
    #         self.send(3, 2, self.id+1, 0)
    #         await asyncio.sleep(0.5)
    #         self.send(1, 0, self.id, 0)

    # def test_setup_leader_send_check_in(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
    #         self.make_leader()
    #         self.send(4, 0, self.id, self.id+1)
    #         await asyncio.sleep(0.4)
    #         self.send(1, 0, self.id, 0)

    # def test_setup_leader_send_delete(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
    #         self.make_leader()
    #         self.send(5, 0, self.id, self.id+1)
    #         await asyncio.sleep(0.4)
    #         self.send(1, 0, self.id, 0)
    
    # def test_setup_leader_wait_max_time(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
    #         self.make_leader()
            
    #         await asyncio.sleep(PROVEN_MAX_WAIT_TIME)
    #         self.send(3, 0, self.id, self.id+1)
    
    # def test_setup_leader_drop_after_sending_d_list(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
    #         self.make_leader()
    #         self.send(3, 0, self.id, self.id+1)

    # def test_attendance_add_device_follower(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
    #         self.make_follower()
    #         while not await self.receive(5, 1):
    #             continue
    #         self.send(2, 0, self.received_leader_id(), self.id)
    #         while True:
    #             await self.receive(3)

    # def test_attendance_invalid_msg_att(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
    #         self.setup()
    #         if await self.receive(15, 1):
    #             self.send(1, 0, self.leader_id, self.id)

    # def test_attendance_invalid_msg_d_list(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
    #         self.setup()
    #         if await self.receive(15, 1):
    #             self.send(3, 0, self.leader_id, self.id)

    # def test_attendance_invalid_msg_check_in(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
    #         self.setup()
    #         if await self.receive(15, 1):
    #             self.send(4, 0, self.leader_id, self.id)

    # def test_attendance_invalid_msg_delete(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
    #         self.setup()
    #         if await self.receive(15, 1):
    #             self.send(5, 0, self.leader_id, self.id)
                
    # def test_check_in_rogue_device(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
            
    #         while await self.receive(10):
    #             if self.received_action() == 4:
    #                 self.send(4, 0, self.received_leader_id(), self.id)
                    
    # async def test_check_in_delayed_correct_follower(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         # format is TIME, TYPE (STATUS, SENT, RECEIVED), CONTENT (<MSG>, <STATUS UPDATE>)
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
            
    #         print("Starting main on device " + str(self.id))
    #         # create device object
    #         self.setup()
            
    #         while True:
    #             #self.transceiver.log("FOLLOWER")
    #             # print("Device:", self.id, self.leader, "\n", self.device_list)
    #             if not await self.receive(duration=TAKEOVER_DURATION):
    #                 print("Is there anybody out there?")
    #                 self.make_leader()
    #                 continue
    #             elif abs(self.received_leader_id() - self.leader_id) > PRECISION_ALLOWANCE:  # account for loss of precision
    #                 # print(self.received_leader_id())
    #                 # print(self.leader_id)
    #                 # print("CONTINUE")
    #                 continue  # message was not from this device's leader - ignore

    #             action = self.received_action()
    #             # print(action)

    #             # messages for all followers
    #             # match action:
    #             #     case Action.ATTENDANCE.value:
    #             #         # prevents deadlock between leader-follower first attendance state
    #             #         if self.numHeardDLIST > 1 and self.device_list.find_device(self.id) is None:  # O(1) operation, quick
    #             #             self.follower_handle_attendance()
    #             #             self.numHeardDLIST = 0
    #             #     case Action.CHECK_IN.value:
    #             #         await asyncio.sleep(0.3)
    #             #         if abs(self.received_follower_id() - self.id) < PRECISION_ALLOWANCE:  # check-in directed to this device
    #             #             print("Follower", self.id, "heard directed check-in")
    #             #             self.follower_respond_check_in()
    #             #         else:
    #             #             self.log_status(f"IGNORED: {self.received_follower_id()}")
    #             #             continue   # not necessary?
    #             #     case Action.DELETE.value:
    #             #         self.follower_drop_disconnected()  # even if self is wrongly deleted
    #             #         # that will be handled later in Action.ATTENDANCE.value
    #             #     case Action.D_LIST.value:
    #             #         self.follower_handle_dlist()
    #             #         self.numHeardDLIST += 1

    #             # running on robots w/ python < 3.10
    #             if action == Action.ATTENDANCE.value:
    #                 # prevents deadlock between leader-follower first attendance state
    #                 if self.numHeardDLIST > 1 and self.device_list.find_device(self.id) is None:  # O(1) operation, quick
    #                     self.follower_handle_attendance()
    #                     self.numHeardDLIST = 0
    #             elif action == Action.CHECK_IN.value:
    #                 await asyncio.sleep(0.3)
    #                 if abs(self.received_follower_id() - self.id) < PRECISION_ALLOWANCE:  # check-in directed to this device
    #                     print("Follower", self.id, "heard directed check-in")
    #                     await self.follower_respond_check_in()
    #                 else:
    #                     self.log_status(f"IGNORED: {self.received_follower_id()}")
    #                     continue   # not necessary?
    #             elif action == Action.DELETE.value:
    #                 self.follower_drop_disconnected()  # even if self is wrongly deleted
    #                 # that will be handled later in Action.ATTENDANCE.value
    #             elif action == Action.D_LIST.value:
    #                 self.follower_handle_dlist()
    #                 self.numHeardDLIST += 1
                        
    # def test_check_in_att_from_wrong_follower(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
            
    #         while await self.receive(10):
    #             if self.received_action() == 4:
    #                 self.send(1, 0, self.received_leader_id(), self.id)
    
    # def test_check_in_att_response_from_wrong_follower(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
            
    #         while await self.receive(10):
    #             if self.received_action() == 4:
    #                 self.send(2, 0, self.received_leader_id(), self.id)
    
    # def test_check_in_delete_from_wrong_follower(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
            
    #         while await self.receive(10):
    #             if self.received_action() == 4:
    #                 self.send(3, 0, self.received_leader_id(), self.id)
    
    # def test_check_in_d_list_from_wrong_follower(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
            
    #         while await self.receive(10):
    #             if self.received_action() == 4:
    #                 self.send(4, 0, self.received_leader_id(), self.id)
    
    # def test_takeover_leader_sends_one_message(self):
    #     with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
    #         self.csvWriter = csv.writer(self.file, dialect='excel')
    #         self.make_leader()
    #         self.send(3, 0, self.id, self.id+1)
            
    # def test_tiebreak_conflicting_leader_sends_after_attendance(self):
    #     self.leader = True
    #     if await self.receive(10, 1):
    #         self.leader_send_attendance()

    #     if self.get_leader():
    #         self.log_status("BECAME LEADER")

    #     if not self.get_leader():
    #         self.log_status("BECAME FOLLOWER")
    
    # def test_tiebreak_conflicting_leader_sends_after_check_in(self):
    #     self.leader = True
    #     if await self.receive(10, 4):
    #         self.leader_send_attendance()

    #     if self.get_leader():
    #         self.log_status("BECAME LEADER")

    #     if not self.get_leader():
    #         self.log_status("BECAME FOLLOWER")
    
    

    # END TEST HARNESS FUNCTIONS


    # TODO: print log to individual files
    async def device_main(self):
        """
        Main looping protocol for ThisDevice.
        """
        with self.outPath.open("w", encoding="utf-8", newline='') as self.file:
            # format is TIME, TYPE (STATUS, SENT, RECEIVED), CONTENT (<MSG>, <STATUS UPDATE>)
            self.csvWriter = csv.writer(self.file, dialect='excel')
            self.log_status("DEVICE_MAIN STARTED.")
            # --- Leader Election ---
            # Perform election if eligible (e.g., not explicitly told to be follower)
            # For simplicity, assume eligible unless known_leaders has entries preventing it.
            if not self.known_leaders: # Check if we know we shouldn't be leader
                elected_leader_id = await self._perform_leader_election()

                # Become leader or follower based on election result
                if elected_leader_id == self.id:
                    print(f"Device {self.id} becoming leader (result of election)")
                    await self.make_leader() # Sets self.leader=True, logs, sends NEW_LEADER
                    self.leader_id = self.id
                    # Ensure self is in device list
                    if not self.device_list.find_device(self.id):
                         # Use get_task() if available, else default 0
                         task = self.get_task() if hasattr(self, 'get_task') else 0
                         await self.device_list.add_device(id=self.id, task_index=task, thisDeviceId=self.id)
                    print("--------Leader---------")
                    await asyncio.sleep(1) # Allow followers to process election outcome
                    await self.leader_send_attendance() # Announce leadership
                else:
                    print(f"Device {self.id} becoming follower of {elected_leader_id} (result of election)")
                    await self.make_follower() # Sets self.leader=False, logs, sends NEW_FOLLOWER
                    self.leader_id = elected_leader_id
                    print("--------Follower, listening--------")
            else:
                # If not eligible, start as follower and try to find the leader
                print(f"Device {self.id} starting as follower (ineligible for election).")
                await self.make_follower()
                self.log_status("STARTING_AS_FOLLOWER_INELIGIBLE")
                print(f"Device {self.id} listening for leader announcement...")
                # Listen for ATTENDANCE to identify the actual leader
                if await self.receive(duration=15, action_value=Action.ATTENDANCE.value):
                     self.leader_id = self.received_leader_id()
                     print(f"Device {self.id} identified leader {self.leader_id}")
                     self.log_status(f"IDENTIFIED_LEADER_{self.leader_id}")
                else:
                     print(f"Device {self.id} could not identify leader after starting as follower.")
                     self.log_status("ERROR_NO_LEADER_FOUND_AS_FOLLOWER")
                     # Consider what to do here - maybe re-attempt election later?

            # --- Main Operation Loop ---
            last_attendance_time = 0
            ATTENDANCE_INTERVAL = 5.0 # Interval for leader sending attendance

            while True:
                # --- Active Device Loop ---
                while self.active:
                    current_time = time.time()
                    if self.get_leader():
                        # --- Leader Logic ---
                        if hasattr(self.transceiver, 'log'): self.transceiver.log("LEADER")
                        self.log_status("LEADER_LOOP")

                        # Send regular attendance
                        if current_time - last_attendance_time > ATTENDANCE_INTERVAL:
                            try:
                                print(f"Leader {self.id} sending attendance")
                                await self.leader_send_attendance()
                                last_attendance_time = current_time
                            except Exception as e:
                                print(f"Error sending leader attendance: {e}")
                                self.log_status(f"ERROR_LEADER_ATTENDANCE_{e}")
                        if not self.get_leader(): continue # Re-check leadership

                        # Send device list periodically or on change
                        try:
                            # print(f"Leader {self.id} sending device list") # Can be noisy
                            await self.leader_send_device_list()
                        except Exception as e:
                            print(f"Error sending device list: {e}")
                            self.log_status(f"ERROR_LEADER_DLIST_{e}")
                        if not self.get_leader(): continue # Re-check leadership

                        # Perform check-ins
                        try:
                            # print(f"Leader {self.id} performing check-in") # Can be noisy
                            await self.leader_perform_check_in()
                        except Exception as e:
                            print(f"Error during check-in: {e}")
                            self.log_status(f"ERROR_LEADER_CHECKIN_{e}")
                        if not self.get_leader(): continue # Re-check leadership

                        # Drop disconnected devices
                        try:
                            # print(f"Leader {self.id} checking for disconnected") # Can be noisy
                            self.leader_drop_disconnected_devices()
                        except Exception as e:
                            print(f"Error dropping devices: {e}")
                            self.log_status(f"ERROR_LEADER_DROP_{e}")

                        await asyncio.sleep(1.0) # Prevent leader busy-loop

                    else: # Not leader
                        # --- Follower Logic ---
                        if hasattr(self.transceiver, 'log'): self.transceiver.log("FOLLOWER")
                        self.log_status("FOLLOWER_LOOP")

                        # Listen for messages from the leader
                        # Timeout slightly longer than leader's attendance interval
                        if not await self.receive(duration=ATTENDANCE_INTERVAL + 3.0):
                            print(f"Follower {self.id} timed out waiting for leader {self.leader_id}.")
                            self.log_status("LEADER_TIMEOUT")
                            # If timeout occurs, consider leader lost, attempt to become leader
                            if self.id not in self.known_leaders:
                                print(f"Follower {self.id} attempting takeover.")
                                self.log_status("ATTEMPTING_TAKEOVER")
                                # Break the inner loop to re-trigger election logic
                                # Setting self.leader = True here might be premature
                                self.known_leaders.clear() # Allow self to participate
                                 # Explicitly perform leader election here
                                elected_leader_id = await self._perform_leader_election()
                                
                                # Update role based on election results
                                if elected_leader_id == self.id:
                                    print(f"Device {self.id} becoming leader after timeout")
                                    await self.make_leader()
                                    self.leader_id = self.id
                                    
                                    # Ensure self is in device list with a task
                                    if not self.device_list.find_device(self.id):
                                        task = self.get_task() if hasattr(self, 'get_task') else 0
                                        await self.device_list.add_device(id=self.id, task_index=task, thisDeviceId=self.id)
                                    
                                    # Announce leadership immediately
                                    await asyncio.sleep(1)  # Allow others to process
                                    await self.leader_send_attendance()
                                else:
                                    print(f"Device {self.id} becoming follower of {elected_leader_id} after timeout")
                                    await self.make_follower()
                                    self.leader_id = elected_leader_id
                                
                            else:
                                print(f"Follower {self.id} ineligible for takeover.")
                                self.log_status("LEADER_TIMEOUT_INELIGIBLE")
                            continue # Continue follower loop if ineligible

                        # Check if message is from the expected leader
                        # Handle case where leader_id might still be 0 if election failed
                        if self.leader_id != 0 and abs(self.received_leader_id() - self.leader_id) > PRECISION_ALLOWANCE:
                            print(f"Follower {self.id} received msg from unexpected source {self.received_leader_id()} (expected {self.leader_id}).")
                            self.log_status(f"UNEXPECTED_SOURCE_{self.received_leader_id()}")
                            # Potentially handle tiebreaker if it's another leader message
                            await self.handle_tiebreaker(self.received_leader_id())
                            continue # Ignore this specific message

                        # Process the message from the leader
                        action = self.received_action()
                        self.log_status(f"RECEIVED_ACTION_{action}_FROM_LEADER_{self.leader_id}")
                        self.last_heard_from_leader = time.time() # Update timestamp

                        match action:
                            case Action.ATTENDANCE.value:
                                print(f"Follower {self.id} received ATTENDANCE from leader {self.leader_id}")
                                # Respond if not in leader's list (implicitly checked by leader)
                                # Or respond if follower just joined/rejoined?
                                # Current logic: Leader adds based on response. Follower sends response via follower_handle_attendance
                                # Let's ensure follower_handle_attendance is called appropriately
                                # Maybe call it here if follower thinks it should be known?
                                # For now, just log receipt. Leader handles adding.
                                pass
                            case Action.CHECK_IN.value:
                                if abs(self.received_follower_id() - self.id) < PRECISION_ALLOWANCE:
                                    print(f"Follower {self.id} received directed check-in.")
                                    await self.follower_respond_check_in()
                                else:
                                    self.log_status(f"IGNORED_CHECKIN_FOR_{self.received_follower_id()}")
                            case Action.DELETE.value:
                                print(f"Follower {self.id} received DELETE for {self.received_follower_id()}")
                                self.follower_drop_disconnected()
                            case Action.D_LIST.value:
                                print(f"Follower {self.id} received D_LIST for {self.received_follower_id()}")
                                self.follower_handle_dlist() if self.get_leader() == False else None# Handles multiple D_LIST msg 
                            case Action.NEW_FOLLOWER.value:
                                print(f"Follower {self.id} received NEW_FOLLOWER for {self.received_follower_id()}")
                                #add follower to device list if not already in device list
                                self.device_list.add_device(id=self.received_follower_id(), task_index=self.received_payload(), thisDeviceId= self.id) if self.received_follower_id() not in self.device_list.get_device_list().keys() else None
                            case _:
                                print(f"Follower {self.id} received unknown action {action} from leader.")
                                self.log_status(f"UNKNOWN_ACTION_{action}")

                # --- Inactive Device Loop ---
                while not self.active:
                    self.log_status("INACTIVE_LOOP")
                    print(f"Device {self.id} is inactive. Waiting for activation.")
                    # Listen specifically for ACTIVATE message directed to this device
                    if await self.receive(duration=5.0):
                        if self.received_action() == Action.ACTIVATE.value and self.received_follower_id() == self.id:
                             print(f"Device {self.id} received ACTIVATE. Reactivating.")
                             self.log_status("REACTIVATED")
                             self.active = True
                             # Rejoin as follower, potentially triggering election if no leader found
                             await self.make_follower()
                             # Break inner inactive loop, outer loop will handle role
                             break # Exit inactive loop
                    await asyncio.sleep(1) # Sleep if no activation message
    

    async def broadcast_candidacy(self):
        """
        Broadcasts this device's candidacy for leadership using attendance message.
        Uses the device's own ID as leader_id to announce candidacy.
        """
        print(f"Device {self.id} broadcasting candidacy")
        candidacy_msg = Message(
            action=Action.CANDIDACY.value,  # Using attendance action for candidacy
            payload=0,                       # No payload needed for candidacy
            leader_id=self.id,              # Using own ID to announce candidacy
            follower_id=0,                  # No follower during election
        )
        await self.transceiver.async_send(candidacy_msg.msg)
        
        self.log_status("BROADCAST CANDIDACY")



class DeviceList:
    """ Container for lightweight Device objects, held by ThisDevice. """
    #self.task_assignments = [1, 2, 3, 4] #1: leader defaulted to quadrant 1; 2-4: followers and their respective quadrant #s

    def __init__(self, num_tasks=8):
        """
        Non-default constructor for DeviceList object.
        :param num_tasks: size of DeviceList, number of tasks.
        """
        #self.manager = Manager()  #use manager to create the shared disctionary
        self.devices = {}  # hashmap of id: Device object
        self.task_options = [1, 2, 3, 4, 5]  
        
    def __getstate__(self):
        # serialize the devices and task options
        return {'devices': dict(self.devices),
                'task_options': self.task_options
        }
        
    def __setstate__(self, state):
        # Restore from serialized data
        self.devices = state['devices']
        self.task_options = state.get('task_options', [1,2,3,4,5])

    def __str__(self):
        """
        String representation of Devices in DeviceList.
        :return: concatenated string representation.
        """

        output = ["DeviceList:"]
        for id, device in self.devices.items():
            task = device.get_task() if device.get_task() != 0 else "Reserve"
            output.append(f"Device ID: {id}, Task: {task}")
        return "\n\t".join(output)

    def __iter__(self):
        """
        Iterator for Devices in DeviceList.
        :return: iterator object.
        """
        return iter(self.devices.items())  # dictionary iterator

    def __len__(self):
        """
        Length of Devices in DeviceList.
        :return: number of Devices in DeviceList as an int.
        """
        return len(self.devices)
    def get_task_options(self):
        """
        Get the task options
        """
        if not hasattr(self, 'task_options') or self.task_options is None:
            self.task_options = [1, 2, 3, 4, 5]
        return self.task_options
        
    def get_device_list(self) -> Dict[int, Device]:
        """
        :return: dictionary of {id : Device}
        """
        return self.devices

    def get_ids(self) -> Set[int]:
        """
        :return: hashable set of device ids
        """

        return set(self.devices.keys())

    def get_devices(self) -> Set[Device]:
        """
        :return: hashable set of Device objects
        """

        return set(self.devices.values())

    def update_num_tasks(self, num_tasks: int):
        """
        Resize DeviceList, used to upscale or downscale tasks.
        :param num_tasks: number of tasks in new operation.
        """
        self.task_options = list(range(num_tasks))

    async def add_device(self, id: int, task_index: int, thisDeviceId: int):
        """
        Creates Device object with id and task, stores in DeviceList.
        :param id: identifier for device, assigned to new Device object.
        :param task_index: index of task for device, assigned to new Device object.
        """
        task = 0
        if 1 <= task_index <= 4:
            task = task_index
            #changing this to async
            
            # call to MainThread.py
            if (id == thisDeviceId):
                await asyncio.create_subprocess_exec("python3", "../RobotBase/MainThread.py", str(task))
        device = Device(id)
        device.set_task(task)
        self.devices[id] = device
        #print("dlist", self.devices.keys())

    def find_device(self, id: int) -> int :
        """
        Finds Device object with target id in DeviceList.
        :param id: identifier for target device.
        :return: Device object if found, None otherwise.
        """
        return self.devices[id] if id in self.devices.keys() else None # type: ignore

    def remove_device(self, id: int) -> bool:
        """
        Removes Device object with target id in DeviceList.
        :param id: identifier for target device
        :return: True if found and removed, False otherwise.
        """
        
        try:
            self.devices.pop(id)
            return True
        except KeyError:
            return False

    def unused_tasks(self) -> List[int]:
        """
        Gets list of tasks not currently assigned to a device.
        :return: list of unused task indices.
        """
        unused_tasks = self.get_task_options().copy()
        for d in self.devices.values():
            if d.get_task() != 0 and d.get_task() in unused_tasks:
                unused_tasks.remove(d.get_task())
        return list(unused_tasks)  # need to index

    def get_reserves(self) -> List[Device]:
        """
        Gets list of reserve devices (not currently assigned a task).
        :return: list of reserve devices.
        """
        reserves = []
        for d in self.devices:
            if d.get_task() == 0:
                reserves.append(d)
        return reserves

    def update_task(self, id: int, task_index: int):
        """
        Reassigns task to target device.
        :param id: identifier for target device.
        :param task_index: index of new task to be assigned to target.
        """
        if id in self.devices:
            if 0 <= task_index < len(self.task_options):
                task = self.task_options[task_index]
            else:
                task = 0
            self.devices[id].set_task(task)

    def get_highest_id(self):
        """
        Gets Device with the largest id, used for leader takeover and tiebreaker.
        :return: Device object with the largest id
        """
        return self.devices[max(self.devices.keys())] if len(self.devices) > 0 else None
    
    def clear(self): 
        self.devices = {}
 
 