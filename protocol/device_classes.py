import time
from message_classes import Message, Action
from typing import Dict, List, Set


class Device:
    """ Lightweight device object for storing in a DeviceList. """

    def __init__(self, id):  # id will be generated by ThisDevice before attendance response
        """
        Non-default constructor for Device object.
        :param id: specified identifier for instance.
        """
        self.id = id  # unique device identifier, randomly generated
        self.leader = False  # initialized as follower
        self.received = None  # holds most recent message payload
        self.missed = 0  # number of missed check-ins, used by current leader
        self.task = -1  # task identifier, -1 denotes reserve

    def get_id(self) -> int:
        """
        :return: Device's identifier.
        """
        return self.id

    def get_leader(self) -> bool:
        """
        :return: Device's current leader status.
        """
        return self.leader

    def get_received(self) -> int:
        """
        :return: Device's most recently received message.
        """
        return self.received

    def get_missed(self) -> int:
        """
        :return: number of missed check-ins for this Device.
        """
        return self.missed

    def get_task(self) -> int:
        """
        :return: device's current task identifier
        """
        return self.task

    def make_leader(self):
        """
        Makes this Device a leader
        """
        self.leader = True

    def make_follower(self):
        """
        Makes this Device a follower
        """
        self.leader = False

    def incr_missed(self) -> int:
        """
        Increments number of missed check-ins by 1.
        :return: new number of missed check-ins.
        """
        self.missed += 1
        return self.missed

    def set_task(self, task: int):
        """
        Sets the task for this Device.
        :param task: task's int identifier
        """
        self.task = task


class ThisDevice(Device):
    """ Object for main protocol to use, subclass of Device. """

    def __init__(self, id, transceiver):  # inclusive bounds
        """
        Constructor (default/non-default) for ThisDevice, creates additional fields.
        :param id: identifier for ThisDevice, either pre-specified or randomly generated.
        """
        super().__init__(id)
        self.leader = True  # start ThisDevice as leader then change accordingly in setup
        self.device_list = DeviceList()  # default sizing
        self.leader_id = None
        self.leader_started_operating = None
        self.task_folder_idx = None  # multiple operations can be preloaded
        self.received = None  # will be an int representation of message
        self.transceiver = transceiver  # plugin object for sending and receiving messages

    def send(self, action, payload, option, leader_id, follower_id, duration=0.0):
        msg = Message(action, payload, option, leader_id, follower_id).msg
        end_time = time.time() + duration
        while time.time() < end_time:
            self.transceiver.send(msg)  # transceiver only deals with integers
            time.sleep(0.2)

    def receive(self, timeout=2, action_value=-1) -> bool:  # int representation of the message (Message.msg)
        end_time = time.time() + timeout
        while time.time() < end_time:
            self.received = self.transceiver.receive(timeout=timeout)
            if self.received_action() == action_value:
                return True
        self.received = None
        return False

    def received_action(self):
        return self.received // 1e26

    def received_leader_id(self):
        return self.received % 1e16 // 1e8

    def received_follower_id(self):
        return self.received % 1e8

    def setup(self):
        if self.receive(3) and self.received_action() == Action.ATTENDANCE.value:
            self.make_follower()
            self.follower_handle_attendance()
            return  # early exit if follower

        self.make_leader()
        self.leader_send_attendance()

    def leader_send_attendance(self):
        self.send(Action.ATTENDANCE.value, 0, 0, self.id, 0, 3)

        new_device = False
        while self.receive(timeout=2, action_value=Action.ATT_RESPONSE.value):
            if self.received_follower_id() not in self.device_list.get_ids():
                self.device_list.add_device(self.received_follower_id(), None)
                new_device = True

        if new_device:
            self.leader_send_device_list()

    def leader_send_device_list(self):
        for index, id in enumerate(self.device_list.get_ids()):
            self.send(Action.D_LIST.value, 0, index, self.id, id, 0.8)

    def follower_handle_attendance(self):
        """
        Called after follower has received attendance message and assigned to self.received.
        :return:
        """
        self.leader_id = self.received_leader_id()
        if self.leader_id not in self.device_list.get_ids():
            self.send(Action.ATT_RESPONSE.value, 0, 0, self.leader_id, self.id, 2)

    # TODO: print log to individual files
    def device_main(self):
        print("Starting main on device " + str(self.id))
        # create device object
        self.setup()

        if self.get_leader():
            print("--------Leader---------")
        else:
            print("--------Follower, listening...--------")

        # global looping
        while True:
            if self.get_leader():
                self.leader_send_attendance()

            if not self.get_leader():
                self.received = self.receive()

                if self.received is None or self.received_leader_id() != self.leader_id:
                    continue

                action = self.received_action()

                # messages for all followers
                match action:
                    case Action.DELETE.value:
                        pass
                    case Action.D_LIST.value:
                        pass
                    case Action.ATTENDANCE:
                        # if not in device list
                        pass
                    case Action.TASK_STOP.value:
                        pass
                    case Action.TASK_START.value:
                        pass
                    case _:
                        print("Is there anybody out there?")


class DeviceList:
    """ Container for lightweight Device objects, held by ThisDevice. """

    def __init__(self, num_tasks=8):
        """
        Non-default constructor for DeviceList object.
        :param num_tasks: size of DeviceList, number of tasks.
        """
        self.devices = {}  # hashmap of id: Device object
        self.task_options = list(range(num_tasks))

    def __str__(self):
        """
        String representation of Devices in DeviceList.
        :return: concatenated string representation.
        """

        output = ["DeviceList:"]
        for id, device in self.devices.items():
            task = device.get_task() if device.get_task() is not None else "Reserve"
            output.append(f"Device ID: {id}, Task: {task}")
        return "\n\t".join(output)

    def __iter__(self):
        """
        Iterator for Devices in DeviceList.
        :return: iterator object.
        """
        return iter(self.devices.items())  # dictionary iterator

    def __len__(self):
        """
        Length of Devices in DeviceList.
        :return: number of Devices in DeviceList as an int.
        """
        return len(self.devices)

    def get_device_list(self) -> Dict[int: Device]:
        return self.devices

    def get_ids(self) -> List[int]:
        return list(self.devices.keys())  # must be positioned

    def get_devices(self) -> Set[Device]:
        return set(self.devices.values())  # hashtable

    def update_num_tasks(self, num_tasks: int):
        """
        Resize DeviceList, used to upscale or downscale tasks.
        :param num_tasks: number of tasks in new operation.
        """
        self.task_options = list(range(num_tasks))

    def add_device(self, id: int, task: int | None):
        """
        Creates Device object with id and task, stores in DeviceList.
        :param id: identifier for device, assigned to new Device object.
        :param task: task for device, assigned to new Device object.
        """
        device = Device(id)
        device.set_task(task)
        self.devices[id] = device

    def find_device(self, id: int) -> int or None:
        """
        Finds Device object with target id in DeviceList.
        :param id: identifier for target device.
        :return: Device object if found, None otherwise.
        """
        return self.devices[id] if id in self.devices.keys() else None

    def remove_device(self, id: int) -> bool:
        """
        Removes Device object with target id in DeviceList.
        :param id: identifier for target device
        :return: True if found and removed, False otherwise.
        """
        try:
            self.devices.pop(id)
            return True
        except KeyError:
            return False

    def unused_tasks(self) -> Set[int]:
        """
        Gets list of tasks not currently assigned to a device.
        :return: list of unused task indices.
        """
        unused_tasks = self.task_options.copy()
        for d in self.devices.values():
            if d.get_task() is not None and d.get_task() in unused_tasks:
                unused_tasks.remove(d.get_task())
        return set(unused_tasks)  # hashtable

    def get_reserves(self) -> List[Device]:
        """
        Gets list of reserve devices (not currently assigned a task).
        :return: list of reserve devices.
        """
        reserves = []
        for d in self.devices:
            if d.get_task() is None:
                reserves.append(d)
        return reserves

    def update_task(self, id: int, task: int):
        """
        Reassigns task to target device.
        :param id: identifier for target device.
        :param task: new task to be assigned to target.
        """
        self.devices[id].set_task(task)

    def get_highest_id(self) -> Device | None:
        """
        Gets Device with the largest id, used for leader takeover and tiebreaker.
        :return: Device object with the largest id
        """
        return self.devices[max(self.devices.keys())] if len(self.devices) > 0 else None

